____
#flashcards/BerLog/6_Context-Free-Grammars  

## Context-Free Grammars

What is an **inductive definition**?
?
An inductive definition defines a set by specifying:
- **Base cases**: elements that are in the set.
- **Inductive rules**: ways to generate new elements from existing ones.
<!--SR:!2025-07-16,39,297-->

It describes the **smallest** set closed under these rules.
<!--SR:!2025-03-14,3,260-->


What is a **context-free grammar (CFG)**?
?
A CFG is a **4-tuple** $\langle V, \Sigma, P, S\rangle$ where:
- $V$ is a set of **variables (non-terminals)**.
- $\Sigma$ is the **alphabet (terminals)**.
- $P$ is a **finite set of production rules**.
- $S \in V$ is the **start symbol**.
<!--SR:!2025-06-15,38,290-->

What is the difference between a **sentential form** and a **sentence** in a CFG?::A **sentential form** may contain **non-terminals**, while a **sentence** contains **only terminals**.
<!--SR:!2025-06-25,48,306-->

When is a language **context-free**?::A language is **context-free** if there exists a **CFG** that generates it.
<!--SR:!2025-06-19,44,306-->

What is the defining property of a **regular grammar**?
?
A grammar is **regular** if all production rules follow one of these forms:
1. $A \rightarrow a$
2. $A \rightarrow aB$
3. $A \rightarrow \Lambda$
<!--SR:!2025-09-15,96,279-->

What is an **ambiguous grammar**?::A CFG is **ambiguous** if there exists a word **$w \in \mathcal{L}(G)$** with at least **two different derivation trees**.
<!--SR:!2025-07-13,66,322-->

What is an **inherently ambiguous language**?::A language is **inherently ambiguous** if **every CFG** that generates it is ambiguous.
<!--SR:!2025-06-21,44,294-->

How do we define the **derivable strings** of a CFG?
?
Given a CFG $\langle V, \Sigma, P, S \rangle$, the set **$Der(v)$** is the smallest set such that:
1. $v \in Der(v)$.
2. If $u \in Der(v)$ and $u \Rightarrow w$, then $w \in Der(v)$.
- Notation:
  - $v \stackrel{*}{\Rightarrow} w$ means $w$ is **derivable** from $v$.
  - $v \stackrel{n}{\Rightarrow} w$ means $w$ is derivable in **$n$ steps**.
<!--SR:!2025-06-14,7,245-->


What is the **relationship between regular grammars and finite automata**?
?
A **regular grammar** generates exactly the **regular languages**, meaning **$\textbf{REG} \subseteq \textbf{CFG}$**.
- A **finite automaton** can be directly **converted into a regular grammar**, and vice versa.
- Transition rules in an NFA **correspond directly** to production rules in a grammar.
<!--SR:!2025-07-04,57,310-->


How do you verify that a CFG generates a given language $X$?
?
To prove **$\mathcal{L}(G) = X$**, we need to show:
1. **$X \subseteq \mathcal{L}(G)$**: Every word in $X$ must be **derivable** in $G$.
2. **$\mathcal{L}(G) \subseteq X$**: Every word generated by $G$ must belong to $X$.
Both require **induction-based proofs**.
<!--SR:!2025-09-09,94,288-->

A **context-free grammar (CFG)** is defined as **$G = \langle V, \Sigma, P, S \rangle$**, where $V$ is the set of **==non-terminals==**, $\Sigma$ is the **==alphabet==**, $P$ is the **==set of rules==**, and $S$ is the **==start symbol==**.
<!--SR:!2025-06-26,49,308!2025-06-16,39,300!2025-07-19,72,326!2025-09-30,115,319-->  

A **sentential form** contains **==both terminals and non-terminals==**, whereas a **sentence** contains **==only terminals==**.
<!--SR:!2025-06-14,37,288!2025-07-08,61,318-->  

A language is **inherently ambiguous** if **==no unambiguous grammar can describe it==**.
<!--SR:!2025-07-02,57,314-->  

## Chomsky Normal Form and CYK Parsing

What are the two fundamental questions in **parsing**?
?
1. **Decision problem**: Is $w \in \mathcal{L}(G)$? (yes/no)
2. **Parsing**: Compute a derivation tree for $w$ in grammar $G$.
<!--SR:!2025-06-29,52,308-->

What is the **goal** of a parsing algorithm?::To construct a **derivation tree** for a given sentence in a grammar.
<!--SR:!2025-07-03,56,310-->

What is the **key drawback** of na√Øve parsing?::It explores all possibilities **exhaustively** in a **depth-first manner with backtracking**, making it inefficient.
<!--SR:!2025-07-12,65,320-->

What is **Chomsky Normal Form?**
?
A CFG is in Chomsky Normal Form if all production rules are of the form:
1. $A \rightarrow BC$ where $B, C \in V$
2. $A \rightarrow a$ where $a \in \Sigma$
<!--SR:!2025-07-04,71,322-->

What is the worst-case time complexity of the **CYK algorithm**?::$O(n^3)$ for a word of length $n$.
<!--SR:!2025-07-11,64,322-->

What are the **advantages of Chomsky Normal Form**?
?
1. **Derivations are non-contracting** (words never get shorter).
2. **Every derivation of a word $w$ has at most $2n - 1$ steps** (if $|w| = n$).
3. **The derivation tree is binary**
4. **Efficient parsing algorithm (CYK)**: Runs in **$O(n^3)$** time.
<!--SR:!2025-07-17,40,259-->

What are the **necessary steps** to convert a CFG into Chomsky Normal Form?
?
1. **Eliminate $\Lambda$-rules** (except for $S \to \Lambda$ if $\Lambda \in \mathcal{L}(G)$).
2. **Eliminate chain rules** ($A \to B$ where $B$ is another variable).
3. **Ensure all right-hand sides** have at most **two** non-terminals ($A \to BC$).
4. **Optional cleanup**: Remove **non-terminating** and **unreachable** variables.
<!--SR:!2025-06-15,8,200-->

How does the **CYK algorithm** work for parsing?
?
1. Construct a **table $X_{ij}$**, where each entry stores **which non-terminals** can derive the substring $w_i \dots w_j$.
2. **Base case**: Fill diagonal entries with non-terminals that **directly produce** terminal symbols.
3. **Inductive step**: For each substring $w_i \dots w_j$,
	- Try **all possible partitions** into $w_i \dots w_k$ and $w_{k+1} \dots w_j$.
	- If $A \to BC$ is in the grammar and $B$ derives $w_i \dots w_k$ and $C$ derives $w_{k+1} \dots w_j$, add $A$ to $X_{ij}$.
4. The word **$w$ is in $\mathcal{L}(G)$** if **$S \in X_{1n}$**.
<!--SR:!2025-07-04,27,236-->

Why is **Chomsky Normal Form necessary** for CYK parsing?
?
Without Chomsky Normal Form, rules could have **more than two** non-terminals, causing the number of possible partitions in CYK to grow **combinatorially** instead of linearly.
<!--SR:!2025-06-24,50,308-->

Why are **regular grammars** conceptually closely related to **regular expressions**? (in fact they can generate the same languages)::Because they build strings **from left to right** using only **concatenation, alternation, and optional termination**, just like regular expressions.
<!--SR:!2025-08-02,56,282-->